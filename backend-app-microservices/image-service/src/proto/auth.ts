// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.2
// source: auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type handleUnaryCall, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";

export const protobufPackage = "auth";

/** ResendConfirmEmailToken */
export interface ResendConfirmEmailTokenRequest {
  confirmEmail: string;
}

export interface ResendConfirmEmailTokenResponse {
  message: string;
}

/** Registration */
export interface RegistrationRequest {
  email: string;
  password: string;
}

export interface RegistrationResponse {
  id: string;
  email: string;
  isConfirmEmail: boolean;
  confirmEmailToken: string;
  refreshToken: string;
}

/** Authorization */
export interface AuthorizationRequest {
  email: string;
  password: string;
}

export interface AuthorizationResponse {
  user: User | undefined;
  accessToken: string;
}

/** RefreshToken */
export interface RefreshTokenRequest {
  refreshToken: string;
}

/** ValidateAccessToken */
export interface ValidateAccessTokenRequest {
  accessToken: string;
}

export interface ValidateAccessTokenResponse {
  isValid: boolean;
  userId?: string | undefined;
}

/** ResetPassword */
export interface ResetPasswordRequest {
  email: string;
}

export interface ResetPasswordResponse {
  message: string;
}

export interface GetUserRequest {
  id: string;
}

export interface UpdateUserRequest {
  id: string;
  email: string;
  password: string;
}

/** ConfirmEmail */
export interface ConfirmEmailRequest {
  confirmEmail: string;
  confirmEmailToken: string;
}

/** User */
export interface User {
  id: string;
  email: string;
  isConfirmEmail: boolean;
  confirmEmailToken: string;
  refreshToken: string;
}

export const AUTH_PACKAGE_NAME = "auth";

function createBaseResendConfirmEmailTokenRequest(): ResendConfirmEmailTokenRequest {
  return { confirmEmail: "" };
}

export const ResendConfirmEmailTokenRequest: MessageFns<ResendConfirmEmailTokenRequest> = {
  encode(message: ResendConfirmEmailTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confirmEmail !== "") {
      writer.uint32(10).string(message.confirmEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendConfirmEmailTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendConfirmEmailTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.confirmEmail = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResendConfirmEmailTokenResponse(): ResendConfirmEmailTokenResponse {
  return { message: "" };
}

export const ResendConfirmEmailTokenResponse: MessageFns<ResendConfirmEmailTokenResponse> = {
  encode(message: ResendConfirmEmailTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendConfirmEmailTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendConfirmEmailTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRegistrationRequest(): RegistrationRequest {
  return { email: "", password: "" };
}

export const RegistrationRequest: MessageFns<RegistrationRequest> = {
  encode(message: RegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRegistrationResponse(): RegistrationResponse {
  return { id: "", email: "", isConfirmEmail: false, confirmEmailToken: "", refreshToken: "" };
}

export const RegistrationResponse: MessageFns<RegistrationResponse> = {
  encode(message: RegistrationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.isConfirmEmail !== false) {
      writer.uint32(24).bool(message.isConfirmEmail);
    }
    if (message.confirmEmailToken !== "") {
      writer.uint32(34).string(message.confirmEmailToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(42).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegistrationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistrationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isConfirmEmail = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.confirmEmailToken = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthorizationRequest(): AuthorizationRequest {
  return { email: "", password: "" };
}

export const AuthorizationRequest: MessageFns<AuthorizationRequest> = {
  encode(message: AuthorizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthorizationResponse(): AuthorizationResponse {
  return { user: undefined, accessToken: "" };
}

export const AuthorizationResponse: MessageFns<AuthorizationResponse> = {
  encode(message: AuthorizationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidateAccessTokenRequest(): ValidateAccessTokenRequest {
  return { accessToken: "" };
}

export const ValidateAccessTokenRequest: MessageFns<ValidateAccessTokenRequest> = {
  encode(message: ValidateAccessTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateAccessTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateAccessTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseValidateAccessTokenResponse(): ValidateAccessTokenResponse {
  return { isValid: false };
}

export const ValidateAccessTokenResponse: MessageFns<ValidateAccessTokenResponse> = {
  encode(message: ValidateAccessTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isValid !== false) {
      writer.uint32(8).bool(message.isValid);
    }
    if (message.userId !== undefined) {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateAccessTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateAccessTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isValid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { email: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseResetPasswordResponse(): ResetPasswordResponse {
  return { message: "" };
}

export const ResetPasswordResponse: MessageFns<ResetPasswordResponse> = {
  encode(message: ResetPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { id: "" };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return { id: "", email: "", password: "" };
}

export const UpdateUserRequest: MessageFns<UpdateUserRequest> = {
  encode(message: UpdateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseConfirmEmailRequest(): ConfirmEmailRequest {
  return { confirmEmail: "", confirmEmailToken: "" };
}

export const ConfirmEmailRequest: MessageFns<ConfirmEmailRequest> = {
  encode(message: ConfirmEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confirmEmail !== "") {
      writer.uint32(10).string(message.confirmEmail);
    }
    if (message.confirmEmailToken !== "") {
      writer.uint32(18).string(message.confirmEmailToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfirmEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.confirmEmail = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.confirmEmailToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUser(): User {
  return { id: "", email: "", isConfirmEmail: false, confirmEmailToken: "", refreshToken: "" };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.isConfirmEmail !== false) {
      writer.uint32(32).bool(message.isConfirmEmail);
    }
    if (message.confirmEmailToken !== "") {
      writer.uint32(42).string(message.confirmEmailToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(50).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isConfirmEmail = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.confirmEmailToken = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface AuthServiceClient {
  registration(request: RegistrationRequest): Observable<RegistrationResponse>;

  authorization(request: AuthorizationRequest): Observable<AuthorizationResponse>;

  confirmEmail(request: ConfirmEmailRequest): Observable<AuthorizationResponse>;

  refreshToken(request: RefreshTokenRequest): Observable<AuthorizationResponse>;

  validateAccessToken(request: ValidateAccessTokenRequest): Observable<ValidateAccessTokenResponse>;

  resetPassword(request: ResetPasswordRequest): Observable<ResetPasswordResponse>;

  getUser(request: GetUserRequest): Observable<User>;

  updateUser(request: UpdateUserRequest): Observable<User>;

  resendConfirmEmailToken(request: ResendConfirmEmailTokenRequest): Observable<ResendConfirmEmailTokenResponse>;
}

export interface AuthServiceController {
  registration(
    request: RegistrationRequest,
  ): Promise<RegistrationResponse> | Observable<RegistrationResponse> | RegistrationResponse;

  authorization(
    request: AuthorizationRequest,
  ): Promise<AuthorizationResponse> | Observable<AuthorizationResponse> | AuthorizationResponse;

  confirmEmail(
    request: ConfirmEmailRequest,
  ): Promise<AuthorizationResponse> | Observable<AuthorizationResponse> | AuthorizationResponse;

  refreshToken(
    request: RefreshTokenRequest,
  ): Promise<AuthorizationResponse> | Observable<AuthorizationResponse> | AuthorizationResponse;

  validateAccessToken(
    request: ValidateAccessTokenRequest,
  ): Promise<ValidateAccessTokenResponse> | Observable<ValidateAccessTokenResponse> | ValidateAccessTokenResponse;

  resetPassword(
    request: ResetPasswordRequest,
  ): Promise<ResetPasswordResponse> | Observable<ResetPasswordResponse> | ResetPasswordResponse;

  getUser(request: GetUserRequest): Promise<User> | Observable<User> | User;

  updateUser(request: UpdateUserRequest): Promise<User> | Observable<User> | User;

  resendConfirmEmailToken(
    request: ResendConfirmEmailTokenRequest,
  ):
    | Promise<ResendConfirmEmailTokenResponse>
    | Observable<ResendConfirmEmailTokenResponse>
    | ResendConfirmEmailTokenResponse;
}

export function AuthServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "registration",
      "authorization",
      "confirmEmail",
      "refreshToken",
      "validateAccessToken",
      "resetPassword",
      "getUser",
      "updateUser",
      "resendConfirmEmailToken",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const AUTH_SERVICE_NAME = "AuthService";

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  registration: {
    path: "/auth.AuthService/Registration",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegistrationRequest) => Buffer.from(RegistrationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegistrationRequest.decode(value),
    responseSerialize: (value: RegistrationResponse) => Buffer.from(RegistrationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegistrationResponse.decode(value),
  },
  authorization: {
    path: "/auth.AuthService/Authorization",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuthorizationRequest) => Buffer.from(AuthorizationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuthorizationRequest.decode(value),
    responseSerialize: (value: AuthorizationResponse) => Buffer.from(AuthorizationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthorizationResponse.decode(value),
  },
  confirmEmail: {
    path: "/auth.AuthService/ConfirmEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ConfirmEmailRequest) => Buffer.from(ConfirmEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ConfirmEmailRequest.decode(value),
    responseSerialize: (value: AuthorizationResponse) => Buffer.from(AuthorizationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthorizationResponse.decode(value),
  },
  refreshToken: {
    path: "/auth.AuthService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest) => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RefreshTokenRequest.decode(value),
    responseSerialize: (value: AuthorizationResponse) => Buffer.from(AuthorizationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthorizationResponse.decode(value),
  },
  validateAccessToken: {
    path: "/auth.AuthService/ValidateAccessToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateAccessTokenRequest) =>
      Buffer.from(ValidateAccessTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateAccessTokenRequest.decode(value),
    responseSerialize: (value: ValidateAccessTokenResponse) =>
      Buffer.from(ValidateAccessTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateAccessTokenResponse.decode(value),
  },
  resetPassword: {
    path: "/auth.AuthService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest) => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResetPasswordRequest.decode(value),
    responseSerialize: (value: ResetPasswordResponse) => Buffer.from(ResetPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ResetPasswordResponse.decode(value),
  },
  getUser: {
    path: "/auth.AuthService/GetUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserRequest) => Buffer.from(GetUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserRequest.decode(value),
    responseSerialize: (value: User) => Buffer.from(User.encode(value).finish()),
    responseDeserialize: (value: Buffer) => User.decode(value),
  },
  updateUser: {
    path: "/auth.AuthService/UpdateUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateUserRequest) => Buffer.from(UpdateUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateUserRequest.decode(value),
    responseSerialize: (value: User) => Buffer.from(User.encode(value).finish()),
    responseDeserialize: (value: Buffer) => User.decode(value),
  },
  resendConfirmEmailToken: {
    path: "/auth.AuthService/ResendConfirmEmailToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResendConfirmEmailTokenRequest) =>
      Buffer.from(ResendConfirmEmailTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ResendConfirmEmailTokenRequest.decode(value),
    responseSerialize: (value: ResendConfirmEmailTokenResponse) =>
      Buffer.from(ResendConfirmEmailTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ResendConfirmEmailTokenResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  registration: handleUnaryCall<RegistrationRequest, RegistrationResponse>;
  authorization: handleUnaryCall<AuthorizationRequest, AuthorizationResponse>;
  confirmEmail: handleUnaryCall<ConfirmEmailRequest, AuthorizationResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, AuthorizationResponse>;
  validateAccessToken: handleUnaryCall<ValidateAccessTokenRequest, ValidateAccessTokenResponse>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, ResetPasswordResponse>;
  getUser: handleUnaryCall<GetUserRequest, User>;
  updateUser: handleUnaryCall<UpdateUserRequest, User>;
  resendConfirmEmailToken: handleUnaryCall<ResendConfirmEmailTokenRequest, ResendConfirmEmailTokenResponse>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
